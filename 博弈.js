/*d小B和小C负责一个货场中货物的装卸工作。货场中的货物实行分区管理，一共有n个分区，每个分区中有满载货物的mi辆货车（1=< i <=n）。第i个分区中的第一辆货车中有xi件货物，第二辆中有xi+1件货物，第三辆有xi+2件货物，以此类推，第mi辆车中有xi+mi-1件货物。
最近货场生意较为红火，老板为提升卸货效率，设置了高额的奖励。为确保拿到奖金，小B和小C展开了卸货比赛，并设定了卸货的规则。两人轮流从货车中卸货，每次两人可以选择一辆车并从中卸下若干件货物（大于0件），第一个无货可取的人将失去奖金。
小B迫切希望能够赢得比赛，她和小C都非常聪明，所以每人每次都会选择最优的数量卸货。先开始卸货的人为first，后开始卸货的为second，她希望你帮她看看谁能够赢得比赛，以便决定选择是先手还是后手。你能帮助她吗？

输入
测试数据有多组，每组测试数据的第一行为一个整数n（1=< n <=10^5），表示货物分区数。随后的n行中每行有两个空格分隔的整数xi和mi（1=<xi, mi <=10^16），表示第i个分区里第一辆货车上货物的数量以及该区中货车的数量。
输出
对每组测试数据，若先开始卸货的能赢，则在单独的行中输出first，否则输出second。

样例输入
2
2 1  --2
3 2  --3 4
4
1 1
1 1
1 1
1 1
*/
// 输出：first 、second 
// 有n堆，每堆有m个货物。每次取货不能全取光
    010
    011
    100
   =101
//异或为奇数，任意拿掉奇数个，会让状态变为偶状态，会让对手陷入偶状态，先手会赢
// 奇状态为胜利的状态，偶状态为失败的状态
function Nimm_Game(n,f)//假设n个数存在数组f[]中,有必胜策略返回1
{
    var flag=0;
    for(var i=1;i<=n;i++)
    flag^=f[i];
    if(flag) return 1;
    return 0;
}

// 当石头数为斐波那契数时，先行者必败；Fn=Fn-1+Fn-2，（0，1，1，2,3,5,8,13....)
// 否则，先行者必胜。
// 斐波那契数：